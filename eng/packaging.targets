<!-- å°† -->
<!-- doc see:https://github.com/dotnet/runtime/blob/main/docs/coding-guidelines/libraries-packaging.md#analyzers- -source-generators -->
<Project>
  <PropertyGroup>
    <BeforePack>$(BeforePack);IncludeAnalyzersInPackage</BeforePack>
  </PropertyGroup>

  <!-- see:https://github.com/dotnet/runtime/blob/253a5c5911d9447ac19864a215408440228da2ed/eng/packaging.targets#L149-L168 -->
  <Target Name="IncludeAnalyzersInPackage" Condition="'@(ProjectReference)' != '' and @(ProjectReference->AnyHaveMetadataValue('PackAsAnalyzer', 'true'))">
    <MSBuild Projects="@(ProjectReference->WithMetadataValue('PackAsAnalyzer', 'true'))"
             Targets="GetAnalyzerPackFiles"
             RemoveProperties="SetTargetFramework">
      <Output TaskParameter="TargetOutputs" ItemName="_AnalyzerFile"/>
    </MSBuild>

    <ItemGroup>
      <Content Include="@(_AnalyzerFile)" Pack="True" Condition="!%(_AnalyzerFile.IsSymbol)"/>
      <!-- Symbols don't honor PackagePath.  By default they are placed in lib/%(TargetFramework).
           Pack does honor TargetPath and does Path.Combine("lib/%(TargetFramework)", "%(TargetPath)"),
           so a rooted path value for TargetPath will override lib.
           https://github.com/NuGet/Home/issues/10860 -->
      <_TargetPathsToSymbols Include="@(_AnalyzerFile)" TargetPath="/%(_AnalyzerFile.PackagePath)" Condition="%(_AnalyzerFile.IsSymbol)"/>
    </ItemGroup>
  </Target>
</Project>
